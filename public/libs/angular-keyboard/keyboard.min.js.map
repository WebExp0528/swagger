{"version":3,"sources":["keyboard.min.js","keyboard.module.js","undefined.js","directives/KbContainerController.js","directives/KbItemController.js","directives/kbAutofocus.js","directives/kbFocus.js","directives/kbItem.js","directives/kbList.js","directives/kbSelect.js","services/kbFocus.js","services/kbScroll.js"],"names":["angular","module","constant","factory","undefined","$log","KbContainerController","$element","this","identifier","ngModel","selected","multiple","cyclic","active","_element","$inject","extend","prototype","initialize","options","isDefined","attrs","kbCyclic","$render","$viewValue","isArray","error","i","kbItem","_locate","bind","select","model","isSelected","push","$setViewValue","deselect","index","indexOf","splice","toggle","previous","prev","_getSiblingItems","next","activate","$error","invoke","items","querySelectorAll","length","element","item","controller","el","siblings","_first","querySelector","_last","nodes","kbScroll","KbItemController","directive","kbFocus","$scope","$watch","kbAutofocus","value","prop","get","label","focus","document","activeElement","setTimeout","on","$root","$$phase","$apply","reset","$animate","require","link","controllers","distance","direction","currentRect","targetRect","left","top","kbContainer","isTabbable","tagName","selectedClass","kbSelectedClass","activeClass","kbActiveClass","$eval","addClass","removeClass","isActive","attr","removeAttr","directions",37,38,39,40,"e","changed","which","getBoundingClientRect","key","trigger","scope","$event","preventDefault","kbInvoke","$on","_label","arguments","set","service","$window","viewportNode","navigator","userAgent","toLowerCase","change","container","property","duration","animate","props","stop","noop","getScrollParent","parent","parentElement","nodeName","parentStyle","getComputedStyle","overflowStyle","overflow","overflowX","overflowY","match","to","offset","cancelAnimation","elRect","pos","Math","ceil","right","bottom","parentPos","innerWidth","innerHeight","parentRect","relTop","relRight","relBottom","relLeft","scrollTop","scrollLeft","cancelParentAnimation","cancelFocus","parentEl","scrollOffset","hasAttribute","setAttribute"],"mappings":"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","file":"keyboard.min.js","sourcesContent":["'use strict';\n\n/**\n * angular-keyboard\n *\n * Keyboard behavior for AngularJS Webapps\n *\n *\n * Inspired by: Apple Mail\n * Implementation inspirated by: WinJS ListView http://try.buildwinjs.com/pages/listview/options/default.html\n */\nangular.module('keyboard.focus', []);\nangular.module('keyboard', ['keyboard.focus']);\n\n/**\n * Register 'undefined' with the `undefined` value.\n */\nangular.module('keyboard').constant('undefined');\n\nangular.module('keyboard').factory('KbContainerController', function (undefined, $log) {\n    /**\n     * @class KbListController\n     * @param {jQElement} $element\n     */\n    function KbContainerController($element) {\n        this.identifier = '[kb-container]';\n        this.ngModel = undefined;\n        this.selected = []; // Selected kbItem(s)\n        this.multiple = false;\n        this.cyclic = false;\n        this.active = undefined; // kbItemController of the active kb-item.\n        this._element = $element[0];\n    }\n    KbContainerController.$inject = ['$element'];\n    angular.extend(KbContainerController.prototype, {\n        /** @lends kbListController */\n\n        /**\n         *\n         * @param {Object} options\n         */\n        initialize: function initialize(options) {\n            this.multiple = angular.isDefined(options.attrs.multiple);\n            this.cyclic = angular.isDefined(options.attrs.kbCyclic);\n            angular.extend(this, options);\n            if (this.ngModel) {\n                this.ngModel.$render = function () {\n                    // Change the selection to model.\n                    if (this.multiple) {\n                        this.selected = this.ngModel.$viewValue;\n                        if (angular.isArray(this.selected) === false) {\n                            if (angular.isDefined(this.selected)) {\n                                $log.error(this.identifier, 'ng-model(multiple) must be an array, got:', this.selected);\n                            }\n                            this.selected = [];\n                        }\n                    } else {\n                        this.selected[0] = this.ngModel.$viewValue;\n                    }\n                    // Activate the first item in the selection.\n                    for (var i in this.selected) {\n                        var kbItem = this._locate(this.selected[i]);\n                        if (kbItem) {\n                            this.active = kbItem;\n                            break;\n                        }\n                    }\n                }.bind(this);\n            }\n        },\n\n        /**\n         * Select the given model.\n         * Or in multiselect mode, add the given model to the selection.\n         *\n         * @param {*} model\n         */\n        select: function select(model) {\n            if (!this.ngModel) {\n                return; // A kb-item can't be selected without a ng-model on the container element.\n            }\n            if (this.multiple) {\n                if (this.isSelected(model) === false) {\n                    this.selected.push(model);\n                    this.ngModel.$setViewValue(this.selected);\n                }\n            } else {\n                this.selected[0] = model;\n                this.ngModel.$setViewValue(model);\n            }\n        },\n        /**\n         * Deselect the given model.\n         * Does nothing if the given model isn't selected.\n         *\n         * @param {*} model\n         */\n        deselect: function deselect(model) {\n            if (!this.ngModel) {\n                return;\n            }\n            var index = this.selected.indexOf(model);\n            if (index !== -1) {\n                this.selected.splice(index, 1);\n                if (this.multiple) {\n                    this.ngModel.$setViewValue(this.selected);\n                } else {\n                    this.ngModel.$setViewValue(undefined);\n                }\n            }\n        },\n        /**\n         * Select or deselect the given model.\n         * Or in multiselect mode, adds or removes the given model to the selection.\n         *\n         * @param {*} model\n         */\n        toggle: function toggle(model) {\n            if (this.isSelected(model)) {\n                this.deselect(model);\n            } else {\n                this.select(model);\n            }\n        },\n        /**\n         * Check if the given model is selected.\n         *\n         * @param {*} model\n         * @returns {Boolean}\n         */\n        isSelected: function isSelected(model) {\n            return this.selected.indexOf(model) !== -1;\n        },\n\n        /**\n         * Activate the previous item.\n         *\n         * @returns {Boolean}\n         */\n        previous: function previous() {\n            var prev = this._getSiblingItems(this.active).previous;\n            if (prev) {\n                this.active = prev;\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Activate the next item.\n         *\n         * @returns {Boolean}\n         */\n        next: function next() {\n            var next = this._getSiblingItems(this.active).next;\n            if (next) {\n                this.active = next;\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Abstract method for when an item is clicked, moved to with the keys.\n         * @param {KbItemController} kbItem\n         * @param {Object} options\n         * @returns {Boolean}\n         */\n        activate: function activate(kbItem, options) {\n            $log.$error(this.identifier, 'activate() is not implemented');\n            return false;\n        },\n\n        /**\n         * Abstract method when an item is clicked or when space or enter is pressed.\n         * @param {KbItemController} kbItem  The active item.\n         * @returns {Boolean}\n         */\n        invoke: function invoke(kbItem) {\n            $log.$error(this.identifier, 'invoke() is not implemented');\n            return false;\n        },\n\n        /**\n         * Returns the (first) kbItemController  which has the given model value.\n         * @returns {KbItemController}\n         */\n        _locate: function _locate(model) {\n            var items = this._element.querySelectorAll('[kb-item]');\n            for (var i = 0; i < items.length; i++) {\n                var kbItem = angular.element(items.item(i)).controller('kbItem');\n                if (kbItem.model === model) {\n                    return kbItem;\n                }\n            }\n        },\n        /**\n         * Returns the element, controller and models from the current, prevous and next item.\n         *\n         * @param {KbItemController} kbItem\n         * @returns {Object} with up to 2 KbItemControllers: previous and next.\n         */\n        _getSiblingItems: function _getSiblingItems(kbItem) {\n            var element = kbItem.element[0];\n            var items = this._element.querySelectorAll('[kb-item]');\n            for (var i = 0; i < items.length; i++) {\n                var el = items.item(i);\n                if (el === element) {\n                    var siblings = {};\n                    if (i !== 0) {\n                        siblings.previous = angular.element(items.item(i - 1)).controller('kbItem');\n                    }\n                    if (i < items.length - 1) {\n                        siblings.next = angular.element(items.item(i + 1)).controller('kbItem');\n                    }\n                    return siblings;\n                }\n            }\n            return {};\n        },\n        /**\n         * Returns the first item.\n         * @returns {kbItemController}\n         */\n        _first: function _first() {\n            var el = this._element.querySelector('[kb-item]');\n            if (el) {\n                return angular.element(el).controller('kbItem');\n            }\n        },\n        /**\n         * Returns the first item.\n         * @returns {kbItemController}\n         */\n        _last: function _last() {\n            var nodes = this._element.querySelectorAll('[kb-item]');\n            if (nodes.length) {\n                return angular.element(nodes[nodes.length - 1]).controller('kbItem');\n            }\n        }\n    });\n    return KbContainerController;\n});\nangular.module('keyboard').factory('KbItemController', function (kbScroll, undefined) {\n\n    /**\n     * @class KbItemController\n     * @param {jQElement} $element\n     */\n    function KbItemController($element) {\n        this.model = undefined;\n        this.element = $element;\n    };\n    KbItemController.$inject = ['$element'];\n    return KbItemController;\n});\n\n/**\n * Set the autofocus based on an expression.\n *\n * Similar to ng-disabled: https://docs.angularjs.org/api/ng/directive/ngDisabled\n *\n * Usage:\n * <input type=\"email\" kb-autofocus=\"email == ''\" />\n */\nangular.module('keyboard.focus').directive('kbFocus', function (kbFocus, $log) {\n    'use strict';\n\n    return function ($scope, el, attrs) {\n        $scope.$watch(attrs.kbAutofocus, function (value) {\n            el.prop('autofocus', !!value);\n        });\n    };\n});\n/**\n * Control focus based on label with the kbFocus service.\n *\n * Inspired by ng-focus-on\n * @link https://github.com/goodeggs/ng-focus-on\n *\n * Usage:\n * <input type=\"text\" kb-focus=\"label\" />\n */\nangular.module('keyboard.focus').directive('kbFocus', function (kbFocus, $log) {\n    return function ($scope, el, attrs) {\n        $scope.$watch(kbFocus.get, function (label) {\n            if (label === attrs.kbFocus) {\n                if (label === '') {\n                    $log.error('[kb-focus] Invalid label in', el[0]);\n                } else {\n                    el[0].focus();\n                    if (document.activeElement !== el[0]) {\n                        // focus() failed?\n                        setTimeout(function () {\n                            // maybe the element was hidden (display:none)\n                            el[0].focus(); // try one more time.\n                        });\n                    }\n                }\n            }\n        });\n        el.on('focus', function () {\n            kbFocus(attrs.kbFocus);\n            if (!$scope.$root.$$phase) {\n                $scope.$apply();\n            }\n        });\n        el.on('blur', function () {\n            if (kbFocus.get() === attrs.kbFocus) {\n                kbFocus.reset();\n                if (!$scope.$root.$$phase) {\n                    $scope.$apply();\n                }\n            }\n        });\n    };\n});\n/**\n * kb-item\n */\nangular.module('keyboard').directive('kbItem', function (KbItemController, $animate, $log) {\n    return {\n        controller: KbItemController,\n        require: ['kbItem', '?^kbList', '?^kbSelect'],\n        link: function link($scope, el, attrs, controllers) {\n            var kbItem = controllers[0];\n            var kbContainer = controllers[1];\n            var isTabbable = el[0].tagName === 'A' || el[0].tagName === 'BUTTON' || el[0].tagName === 'AREA';\n\n            for (var i = 1; i < controllers.length; i++) {\n                if (controllers[i]) {\n                    kbContainer = controllers[i];\n                }\n            }\n            if (!kbContainer) {\n                $log.error(\"Controller 'kbList' or 'kbSelect', required by directive 'kbItem', can't be found!\");\n                return;\n            }\n\n            var selectedClass = attrs.kbSelectedClass || 'kb-selected';\n            var activeClass = attrs.kbActiveClass || 'kb-active';\n\n            // Bind the model\n            kbItem.model = $scope.$eval(attrs.kbItem);\n            $scope.$watch(attrs.kbItem, function (model) {\n                kbItem.model = model;\n            });\n\n            if (typeof kbContainer.active === 'undefined') {\n                kbContainer.active = kbItem;\n            } else if (kbContainer.isSelected(kbItem.model) && kbContainer.isSelected(kbContainer.active.model) === false) {\n                kbContainer.active = kbItem;\n            }\n            $scope.$watch(function () {\n                return kbContainer.isSelected(kbItem.model);\n            }, function (isSelected) {\n                if (isSelected) {\n                    $animate.addClass(el, selectedClass);\n                } else {\n                    $animate.removeClass(el, selectedClass);\n                }\n            });\n            $scope.$watch(function () {\n                return kbContainer.active === kbItem;\n            }, function (isActive) {\n                if (isActive) {\n                    el.attr('tabindex', 0);\n                    $animate.addClass(el, activeClass);\n                } else {\n                    $animate.removeClass(el, activeClass);\n                    if (isTabbable) {\n                        el.attr('tabindex', -1);\n                    } else {\n                        el.removeAttr('tabindex');\n                    }\n                }\n            });\n\n            /**\n             * Calculates the distance to the ClientRect in a given direction.\n             * Allows for keyboard navigation based on the relative visual location of the element.\n             *\n             * @param {string} direction 'up', 'left', 'right' or 'down',\n             * @param {ClientRect} currentRect The position of the current item.\n             * @return {Number}\n             */\n            function distance(direction, currentRect, targetRect) {\n                if (direction === 'left' && targetRect.left < currentRect.left) {\n                    return currentRect.left - targetRect.left;\n                }\n                if (direction === 'up' && targetRect.top < currentRect.top) {\n                    return currentRect.top - targetRect.top;\n                }\n                if (direction === 'right' && targetRect.left > currentRect.left) {\n                    return targetRect.left - currentRect.left;\n                }\n                if (direction === 'down' && targetRect.top > currentRect.top) {\n                    return targetRect.top - currentRect.top;\n                }\n                return 0;\n            }\n            // { e.which: direction }\n            var directions = {\n                37: 'left',\n                38: 'up',\n                39: 'right',\n                40: 'down'\n            };\n            el.on('keydown', function (e) {\n                var changed = false;\n                var invoke = false;\n                if (e.which >= 37 && e.which <= 40) {\n                    // An arrow-key?\n                    var siblings = kbContainer._getSiblingItems(kbItem);\n                    var currentRect = el[0].getBoundingClientRect();\n                    if (siblings.previous && distance(directions[e.which], currentRect, siblings.previous.element[0].getBoundingClientRect())) {\n                        kbContainer.activate(siblings.previous);\n                        changed = true;\n                    }\n                    if (siblings.next && distance(directions[e.which], currentRect, siblings.next.element[0].getBoundingClientRect())) {\n                        kbContainer.activate(siblings.next);\n                        changed = true;\n                    }\n                    if (changed === false && (!siblings.next || !siblings.previous)) {\n                        // Detect if we reached the end/begin.\n                        var key = e.which;\n                        var trigger = false;\n                        if (e.which <= 38) {\n                            key += 2;\n                        } else {\n                            key -= 2;\n                        }\n                        // Check distance in the oppositie direction\n                        if (siblings.next && distance(directions[key], currentRect, siblings.next.element[0].getBoundingClientRect())) {\n                            if (kbContainer.cyclic) {\n                                kbContainer.activate(kbContainer._last());\n                                changed = true;\n                            } else {\n                                trigger = 'kbReachedBegin';\n                            }\n                        }\n                        if (siblings.previous && distance(directions[key], currentRect, siblings.previous.element[0].getBoundingClientRect())) {\n                            if (kbContainer.cyclic) {\n                                kbContainer.activate(kbContainer._first());\n                                changed = true;\n                            } else {\n                                trigger = 'kbReachedEnd';\n                            }\n                        }\n                        if (trigger && kbContainer.attrs[trigger]) {\n                            // Trigger kb-reached-end and kb-reached-begin events\n                            angular.element(kbContainer._element).scope().$eval(kbContainer.attrs[trigger], { $event: e });\n                        }\n                    }\n                    if (changed) {\n                        e.preventDefault(); // prevent viewport movement\n                    }\n                } else if (e.which === 32) {\n                        // Space\n                        e.preventDefault(); // prevent viewport movement\n                        invoke = true;\n                    } else if (e.which === 13) {\n                        // Enter\n                        invoke = true;\n                    }\n                if (changed || invoke) {\n                    if (invoke) {\n                        kbContainer.invoke(kbItem);\n                        if (attrs.kbInvoke) {\n                            $scope.$eval(attrs.kbInvoke, { $event: e });\n                        }\n                    }\n                    $scope.$apply();\n                }\n            });\n            el.on('click', function (e) {\n                kbContainer.activate(kbItem);\n                kbContainer.invoke(kbItem);\n                if (attrs.kbInvoke) {\n                    $scope.$eval(attrs.kbInvoke, { $event: e });\n                }\n                $scope.$apply();\n            });\n            $scope.$on('$destroy', function () {\n                kbContainer.active = kbContainer._first();\n            });\n        }\n    };\n});\n\n/**\n * kb-list directive\n *\n * Usage:\n * <div kb-list ng-model=\"selection\"> ... <div kb-item=\"aItem\">...</div> ... </div>\n */\nangular.module('keyboard').directive('kbList', function (KbContainerController, kbScroll) {\n    return {\n        controller: KbContainerController,\n        require: ['kbList', '?ngModel'],\n        link: function link($scope, el, attrs, controllers) {\n            var kbContainer = controllers[0];\n            kbContainer.initialize({\n                identifier: '[kb-list]',\n                ngModel: controllers[1],\n                attrs: attrs,\n                activate: function activate(kbItem) {\n                    this.active = kbItem;\n                    this.select(kbItem.model);\n                    kbScroll.focus(kbItem.element[0]);\n                },\n                invoke: function invoke() {\n                    return false;\n                }\n            });\n        }\n    };\n});\n/**\n * kb-select directive\n *\n * Usage:\n * <div kb-select ng-model=\"selection\"> ... <div kb-item=\"aItem\">...</div> ... </div>\n */\nangular.module('keyboard').directive('kbSelect', function (KbContainerController, kbScroll) {\n    return {\n        controller: KbContainerController,\n        require: ['kbSelect', 'ngModel'],\n        link: function link($scope, el, attrs, controllers) {\n            var kbContainer = controllers[0];\n\n            kbContainer.initialize({\n                identifier: '[kb-select]',\n                ngModel: controllers[1],\n                attrs: attrs,\n                activate: function activate(kbItem) {\n                    this.active = kbItem;\n                    kbScroll.focus(kbItem.element[0]);\n                },\n                invoke: function invoke(kbItem) {\n                    this.toggle(kbItem.model);\n                    return true;\n                }\n            });\n        }\n    };\n});\n/**\n * Service for setting the focus on elements with the kb-focus directive.\n *\n * Inspired by ng-focus-on\n * @link https://github.com/goodeggs/ng-focus-on\n *\n * Usage:\n * kbFocus('email'); // set focus\n * kbFocus(); // get current focus\n */\nangular.module('keyboard.focus').factory('kbFocus', function ($log) {\n    var _label = ''; // Current focussed label\n\n    /**\n     * Getter and setter for the focus.\n     *\n     * @param {String} label\n     * @returns {String}\n     */\n    var kbFocus = function kbFocus(label) {\n        if (arguments.length === 0) {\n            return _label;\n        }\n        kbFocus.set(label);\n    };\n    kbFocus.get = function () {\n        return _label;\n    };\n    kbFocus.set = function (label) {\n        if (typeof label === 'string') {\n            _label = label;\n        } else {\n            $log.error('[kbFocus] label must be a string, got', label);\n        }\n    };\n    kbFocus.reset = function () {\n        _label = '';\n    };\n    return kbFocus;\n});\n\n/**\n * Helper for scrolling an element into the viewable area.\n *\n * Usage:\n * kbScroll.to(el, offset, duration)\n */\nangular.module('keyboard').service('kbScroll', function ($window) {\n\n    // Most browsers scroll via scrollTop on the <body> element.\n    var viewportNode = 'BODY';\n    if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {\n        viewportNode = 'HTML'; // Except Firefox, which uses scrollTop on <html> element.\n    }\n\n    var kbScroll = this;\n\n    /**\n     * Change the scrollposition animated and return a function that cancels the animation.\n     *\n     * @param {Element} container\n     * @param {String} property 'scrollTop' or 'scrollLeft'\n     * @param {Number} value\n     * @param {Number} duration\n     * @returns {Function}\n     */\n    this.change = function (container, property, value, duration) {\n        if (duration && angular.element.prototype.animate) {\n            // jQuery.animate is available?\n            var el = angular.element(container);\n            var props = {};\n            props[property] = value;\n            el.animate(props, duration);\n            return function () {\n                el.stop(true, true);\n            };\n        } else {\n            container[property] = value;\n            return angular.noop;\n        }\n    };\n\n    /**\n     * Get the scrollcontainer of the given element\n     * @param {Element} el\n     * @returns {Element}\n     */\n    this.getScrollParent = function (el) {\n        var parent = el.parentElement;\n        while (parent.nodeName !== viewportNode) {\n            var parentStyle = getComputedStyle(parent);\n            var overflowStyle = parentStyle.overflow + parentStyle.overflowX + parentStyle.overflowY;\n            if (overflowStyle.match(/scroll|hidden/)) {\n                break;\n            }\n            parent = parent.parentElement;\n        }\n        return parent;\n    };\n\n    /**\n     *\n     * @param {Element} el  The DOMElement\n     * @param {Object} offset  Allowed hidden\n     * @param {Number} duration  Duration of the animation in ms\n     * @returns {Function} cancel animation\n     */\n    this.to = function (el, offset, duration) {\n        var cancelAnimation = angular.noop;\n        var parent = kbScroll.getScrollParent(el);\n        var elRect = el.getBoundingClientRect();\n        var pos = {\n            top: Math.ceil(elRect.top),\n            right: Math.ceil(elRect.right),\n            bottom: Math.ceil(elRect.bottom),\n            left: Math.ceil(elRect.left)\n        };\n        // @todo Add outline-width to pos\n        if (parent.nodeName === viewportNode) {\n            var parentPos = {\n                top: 0,\n                right: $window.innerWidth,\n                bottom: $window.innerHeight,\n                left: 0\n            };\n        } else {\n            var parentRect = parent.getBoundingClientRect();\n            var parentPos = {\n                top: Math.ceil(parentRect.top),\n                right: Math.ceil(parentRect.right),\n                bottom: Math.ceil(parentRect.bottom),\n                left: Math.ceil(parentRect.left)\n            };\n        }\n        //        console.info(el.nodeName, pos, 'in', parent.nodeName, parentPos, 'offset', offset);\n\n        var relTop = pos.top - parentPos.top;\n        var relRight = parentPos.right - pos.right;\n        var relBottom = parentPos.bottom - pos.bottom;\n        var relLeft = pos.left - parentPos.left;\n\n        if (relTop + offset.top < 0) {\n            // up\n            cancelAnimation = kbScroll.change(parent, 'scrollTop', parent.scrollTop + relTop + offset.top, duration);\n            relBottom += relTop;\n            relTop = 0;\n        } else if (relBottom + offset.bottom < 0) {\n            // down\n            cancelAnimation = kbScroll.change(parent, 'scrollTop', parent.scrollTop - relBottom + offset.bottom, duration);\n            relTop += relBottom;\n            relBottom = 0;\n        }\n        if (relLeft + offset.left < 0) {\n            // left\n            cancelAnimation = kbScroll.change(parent, 'scrollLeft', parent.scrollLeft + relLeft + offset.left, duration);\n            relRight += relLeft;\n            relLeft = 0;\n        } else if (relRight + offset.right < 0) {\n            // right\n            cancelAnimation = kbScroll.change(parent, 'scrollLeft', parent.scrollLeft - relRight + offset.right, duration);\n            relLeft += relRight;\n            relRight = 0;\n        }\n        if (parent.nodeName === viewportNode) {\n            return cancelAnimation;\n        }\n        var cancelParentAnimation = kbScroll.to(parent, { top: relTop, right: relTop, bottom: relBottom, left: relLeft }, duration);\n        return function () {\n            cancelAnimation();\n            cancelParentAnimation();\n        };\n    };\n\n    var cancelFocus = angular.noop;\n    /**\n     * Focus an element\n     * @param {Element} el\n     */\n    this.focus = function (el) {\n        cancelFocus();\n        var parentEl = this.getScrollParent(el);\n        var scrollOffset = {\n            top: parentEl.scrollTop,\n            left: parentEl.scrollLeft\n        };\n        if (!el.hasAttribute('tabindex')) {\n            el.setAttribute('tabindex', 0);\n        };\n        el.focus();\n        if (parentEl.scrollTop !== scrollOffset.top || parentEl.scrollLeft !== scrollOffset.left) {\n            // position changed?\n            parentEl.scrollTop = scrollOffset.top;\n            parentEl.scrollLeft = scrollOffset.left;\n            cancelFocus = this.to(el, { top: 0, right: 0, bottom: 0, left: 0 }, 200);\n        }\n    };\n});","/**\n * angular-keyboard\n *\n * Keyboard behavior for AngularJS Webapps\n *\n *\n * Inspired by: Apple Mail\n * Implementation inspirated by: WinJS ListView http://try.buildwinjs.com/pages/listview/options/default.html\n */\nangular.module('keyboard.focus', []);\nangular.module('keyboard', ['keyboard.focus']);\n","/**\n * Register 'undefined' with the `undefined` value.\n */\nangular.module('keyboard').constant('undefined');\n","angular.module('keyboard').factory('KbContainerController', function (undefined, $log) {\n    /**\n     * @class KbListController\n     * @param {jQElement} $element\n     */\n    function KbContainerController($element) {\n        this.identifier = '[kb-container]';\n        this.ngModel = undefined;\n        this.selected = []; // Selected kbItem(s)\n        this.multiple = false;\n        this.cyclic = false;\n        this.active = undefined; // kbItemController of the active kb-item.\n        this._element = $element[0];\n    }\n    KbContainerController.$inject = ['$element'];\n    angular.extend(KbContainerController.prototype, {\n        /** @lends kbListController */\n\n        /**\n         *\n         * @param {Object} options\n         */\n        initialize: function (options) {\n            this.multiple = angular.isDefined(options.attrs.multiple);\n            this.cyclic = angular.isDefined(options.attrs.kbCyclic);\n            angular.extend(this, options);\n            if (this.ngModel) {\n                this.ngModel.$render = function () {\n                    // Change the selection to model.\n                    if (this.multiple) {\n                        this.selected = this.ngModel.$viewValue;\n                        if (angular.isArray(this.selected) === false) {\n                            if (angular.isDefined(this.selected)) {\n                                $log.error(this.identifier, 'ng-model(multiple) must be an array, got:', this.selected);\n                            }\n                            this.selected = [];\n                        }\n                    } else {\n                        this.selected[0] = this.ngModel.$viewValue;\n                    }\n                    // Activate the first item in the selection.\n                    for (var i in this.selected) {\n                        var kbItem = this._locate(this.selected[i]);\n                        if (kbItem) {\n                            this.active = kbItem;\n                            break;\n                        }\n                    }\n                }.bind(this);\n            }\n        },\n\n        /**\n         * Select the given model.\n         * Or in multiselect mode, add the given model to the selection.\n         *\n         * @param {*} model\n         */\n        select: function (model) {\n            if (!this.ngModel) {\n                return; // A kb-item can't be selected without a ng-model on the container element.\n            }\n            if (this.multiple) {\n                if (this.isSelected(model) === false) {\n                    this.selected.push(model);\n                    this.ngModel.$setViewValue(this.selected);\n                }\n            } else {\n                this.selected[0] = model;\n                this.ngModel.$setViewValue(model);\n            }\n        },\n        /**\n         * Deselect the given model.\n         * Does nothing if the given model isn't selected.\n         *\n         * @param {*} model\n         */\n        deselect: function (model) {\n            if (!this.ngModel) {\n                return;\n            }\n            var index = this.selected.indexOf(model);\n            if (index !== -1) {\n                this.selected.splice(index, 1);\n                if (this.multiple) {\n                    this.ngModel.$setViewValue(this.selected);\n                } else {\n                    this.ngModel.$setViewValue(undefined);\n                }\n            }\n\n        },\n        /**\n         * Select or deselect the given model.\n         * Or in multiselect mode, adds or removes the given model to the selection.\n         *\n         * @param {*} model\n         */\n        toggle: function (model) {\n            if (this.isSelected(model)) {\n                this.deselect(model);\n            } else {\n                this.select(model);\n            }\n        },\n        /**\n         * Check if the given model is selected.\n         *\n         * @param {*} model\n         * @returns {Boolean}\n         */\n        isSelected: function (model) {\n            return (this.selected.indexOf(model) !== -1);\n        },\n\n        /**\n         * Activate the previous item.\n         *\n         * @returns {Boolean}\n         */\n        previous: function () {\n            var prev = this._getSiblingItems(this.active).previous;\n            if (prev) {\n                this.active = prev;\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Activate the next item.\n         *\n         * @returns {Boolean}\n         */\n        next: function () {\n            var next = this._getSiblingItems(this.active).next;\n            if (next) {\n                this.active = next;\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Abstract method for when an item is clicked, moved to with the keys.\n         * @param {KbItemController} kbItem\n         * @param {Object} options\n         * @returns {Boolean}\n         */\n        activate: function (kbItem, options) {\n            $log.$error(this.identifier, 'activate() is not implemented');\n            return false;\n        },\n\n        /**\n         * Abstract method when an item is clicked or when space or enter is pressed.\n         * @param {KbItemController} kbItem  The active item.\n         * @returns {Boolean}\n         */\n        invoke: function (kbItem) {\n            $log.$error(this.identifier, 'invoke() is not implemented');\n            return false;\n        },\n\n        /**\n         * Returns the (first) kbItemController  which has the given model value.\n         * @returns {KbItemController}\n         */\n        _locate: function (model) {\n            var items = this._element.querySelectorAll('[kb-item]');\n            for (var i = 0; i < items.length; i++) {\n                var kbItem = angular.element(items.item(i)).controller('kbItem');\n                if (kbItem.model === model) {\n                    return kbItem;\n                }\n            }\n        },\n        /**\n         * Returns the element, controller and models from the current, prevous and next item.\n         *\n         * @param {KbItemController} kbItem\n         * @returns {Object} with up to 2 KbItemControllers: previous and next.\n         */\n        _getSiblingItems: function (kbItem) {\n            var element = kbItem.element[0];\n            var items = this._element.querySelectorAll('[kb-item]');\n            for (var i = 0; i < items.length; i++) {\n                var el = items.item(i);\n                if (el === element) {\n                    var siblings = {};\n                    if (i !== 0) {\n                        siblings.previous = angular.element(items.item(i - 1)).controller('kbItem');\n                    }\n                    if (i < items.length - 1) {\n                        siblings.next = angular.element(items.item(i + 1)).controller('kbItem');\n                    }\n                    return siblings;\n                }\n            }\n            return {};\n        },\n        /**\n         * Returns the first item.\n         * @returns {kbItemController}\n         */\n        _first: function () {\n            var el = this._element.querySelector('[kb-item]');\n            if (el) {\n                return angular.element(el).controller('kbItem');\n            }\n        },\n        /**\n         * Returns the first item.\n         * @returns {kbItemController}\n         */\n        _last: function () {\n            var nodes = this._element.querySelectorAll('[kb-item]');\n            if (nodes.length) {\n                return angular.element(nodes[nodes.length - 1]).controller('kbItem');\n            }\n        }\n    });\n    return KbContainerController;\n});","angular.module('keyboard').factory('KbItemController', function (kbScroll, undefined) {\n\n    /**\n     * @class KbItemController\n     * @param {jQElement} $element\n     */\n    function KbItemController($element) {\n        this.model = undefined;\n    \tthis.element = $element;\n    };\n    KbItemController.$inject = ['$element'];\n    return KbItemController;\n});\n","/**\n * Set the autofocus based on an expression.\n *\n * Similar to ng-disabled: https://docs.angularjs.org/api/ng/directive/ngDisabled\n *\n * Usage:\n * <input type=\"email\" kb-autofocus=\"email == ''\" />\n */\nangular.module('keyboard.focus').directive('kbFocus', function (kbFocus, $log) {\n    'use strict';\n    return function ($scope, el, attrs) {\n        $scope.$watch(attrs.kbAutofocus, function (value) {\n            el.prop('autofocus', !!value);\n        });\n    };\n});","/**\n * Control focus based on label with the kbFocus service.\n *\n * Inspired by ng-focus-on\n * @link https://github.com/goodeggs/ng-focus-on\n *\n * Usage:\n * <input type=\"text\" kb-focus=\"label\" />\n */\nangular.module('keyboard.focus').directive('kbFocus', function (kbFocus, $log) {\n    return function ($scope, el, attrs) {\n        $scope.$watch(kbFocus.get, function (label) {\n            if (label === attrs.kbFocus) {\n                if (label === '') {\n                    $log.error('[kb-focus] Invalid label in', el[0]);\n                } else {\n                    el[0].focus();\n                    if (document.activeElement !== el[0]) { // focus() failed?\n                        setTimeout(function () { // maybe the element was hidden (display:none)\n                            el[0].focus(); // try one more time.\n                        });\n                    }\n                }\n            }\n        });\n        el.on('focus', function () {\n            kbFocus(attrs.kbFocus);\n            if (!$scope.$root.$$phase) {\n                $scope.$apply();\n            }\n        });\n        el.on('blur', function () {\n            if (kbFocus.get() === attrs.kbFocus) {\n                kbFocus.reset();\n                if (!$scope.$root.$$phase) {\n                    $scope.$apply();\n                }\n            }\n        });\n    };\n});","/**\n * kb-item\n */\nangular.module('keyboard').directive('kbItem', function (KbItemController, $animate, $log) {\n    return {\n        controller: KbItemController,\n        require: ['kbItem', '?^kbList', '?^kbSelect'],\n        link: function ($scope, el, attrs, controllers) {\n            var kbItem = controllers[0];\n            var kbContainer = controllers[1];\n            var isTabbable = (el[0].tagName === 'A' || el[0].tagName === 'BUTTON' || el[0].tagName === 'AREA');\n\n            for (var i = 1; i < controllers.length; i++) {\n                if (controllers[i]) {\n                    kbContainer = controllers[i];\n                }\n            }\n            if (!kbContainer) {\n                $log.error(\"Controller 'kbList' or 'kbSelect', required by directive 'kbItem', can't be found!\");\n                return;\n            }\n\n            var selectedClass = attrs.kbSelectedClass || 'kb-selected';\n            var activeClass = attrs.kbActiveClass || 'kb-active';\n\n            // Bind the model\n            kbItem.model = $scope.$eval(attrs.kbItem);\n            $scope.$watch(attrs.kbItem, function (model) {\n                kbItem.model = model;\n            });\n\n            if (typeof kbContainer.active === 'undefined') {\n                kbContainer.active = kbItem;\n            } else if (kbContainer.isSelected(kbItem.model) && kbContainer.isSelected(kbContainer.active.model) === false) {\n                kbContainer.active = kbItem;\n            }\n            $scope.$watch(function () {\n                return kbContainer.isSelected(kbItem.model);\n            }, function (isSelected) {\n                if (isSelected) {\n                    $animate.addClass(el, selectedClass);\n                } else {\n                    $animate.removeClass(el, selectedClass);\n                }\n            });\n            $scope.$watch(function () {\n                return kbContainer.active === kbItem;\n            }, function (isActive) {\n                if (isActive) {\n                    el.attr('tabindex', 0);\n                    $animate.addClass(el, activeClass);\n                } else {\n                    $animate.removeClass(el, activeClass);\n                    if (isTabbable) {\n                        el.attr('tabindex', -1);\n                    } else {\n                        el.removeAttr('tabindex');\n                    }\n                }\n            });\n\n            /**\n             * Calculates the distance to the ClientRect in a given direction.\n             * Allows for keyboard navigation based on the relative visual location of the element.\n             *\n             * @param {string} direction 'up', 'left', 'right' or 'down',\n             * @param {ClientRect} currentRect The position of the current item.\n             * @return {Number}\n             */\n            function distance(direction, currentRect, targetRect) {\n                if (direction === 'left' && targetRect.left < currentRect.left) {\n                    return currentRect.left - targetRect.left;\n                }\n                if (direction === 'up' && targetRect.top < currentRect.top) {\n                    return currentRect.top - targetRect.top;\n                }\n                if (direction === 'right' && targetRect.left > currentRect.left) {\n                    return targetRect.left - currentRect.left;\n                }\n                if (direction === 'down' && targetRect.top > currentRect.top) {\n                    return targetRect.top - currentRect.top;\n                }\n                return 0;\n            }\n            // { e.which: direction }\n            var directions = {\n                37: 'left',\n                38: 'up',\n                39: 'right',\n                40: 'down'\n            };\n            el.on('keydown', function (e) {\n                var changed = false;\n                var invoke = false;\n                if (e.which >= 37 && e.which <= 40) { // An arrow-key?\n                    var siblings = kbContainer._getSiblingItems(kbItem);\n                    var currentRect = el[0].getBoundingClientRect();\n                    if (siblings.previous && distance(directions[e.which], currentRect, siblings.previous.element[0].getBoundingClientRect())) {\n                        kbContainer.activate(siblings.previous);\n                        changed = true;\n                    }\n                    if (siblings.next && distance(directions[e.which], currentRect, siblings.next.element[0].getBoundingClientRect())) {\n                        kbContainer.activate(siblings.next);\n                        changed = true;\n                    }\n                    if (changed === false && (!siblings.next || !siblings.previous)) {\n                        // Detect if we reached the end/begin.\n                        var key = e.which;\n                        var trigger = false;\n                        if (e.which <= 38) {\n                            key += 2;\n                        } else {\n                            key -= 2;\n                        }\n                        // Check distance in the oppositie direction\n                        if (siblings.next && distance(directions[key], currentRect, siblings.next.element[0].getBoundingClientRect())) {\n                            if (kbContainer.cyclic) {\n                                kbContainer.activate(kbContainer._last());\n                                changed = true;\n                            } else {\n                                trigger = 'kbReachedBegin';\n                            }\n                        }\n                        if (siblings.previous && distance(directions[key], currentRect, siblings.previous.element[0].getBoundingClientRect())) {\n                            if (kbContainer.cyclic) {\n                                kbContainer.activate(kbContainer._first());\n                                changed = true;\n                            } else {\n                                trigger = 'kbReachedEnd';\n                            }\n                        }\n                        if (trigger && kbContainer.attrs[trigger]) { // Trigger kb-reached-end and kb-reached-begin events\n                            angular.element(kbContainer._element).scope().$eval(kbContainer.attrs[trigger], { $event: e});\n                        }\n                    }\n                    if (changed) {\n                        e.preventDefault(); // prevent viewport movement\n                    }\n                } else if (e.which === 32) { // Space\n                    e.preventDefault(); // prevent viewport movement\n                    invoke = true;\n                } else if (e.which === 13) { // Enter\n                    invoke = true;\n                }\n                if (changed || invoke) {\n                    if (invoke) {\n                        kbContainer.invoke(kbItem);\n                        if (attrs.kbInvoke) {\n                            $scope.$eval(attrs.kbInvoke, {$event: e});\n                        }\n                    }\n                    $scope.$apply();\n                }\n            });\n            el.on('click', function (e) {\n                kbContainer.activate(kbItem);\n                kbContainer.invoke(kbItem);\n                if (attrs.kbInvoke) {\n                    $scope.$eval(attrs.kbInvoke, {$event: e});\n                }\n                $scope.$apply();\n            });\n            $scope.$on('$destroy', function () {\n               kbContainer.active = kbContainer._first();\n            });\n        }\n    };\n});\n","/**\n * kb-list directive\n *\n * Usage:\n * <div kb-list ng-model=\"selection\"> ... <div kb-item=\"aItem\">...</div> ... </div>\n */\nangular.module('keyboard').directive('kbList', function (KbContainerController, kbScroll) {\n    return {\n        controller: KbContainerController,\n        require: ['kbList', '?ngModel'],\n        link: function ($scope, el, attrs, controllers) {\n            var kbContainer = controllers[0];\n            kbContainer.initialize({\n                identifier: '[kb-list]',\n                ngModel: controllers[1],\n                attrs: attrs,\n                activate: function (kbItem) {\n                    this.active = kbItem;\n                    this.select(kbItem.model);\n                    kbScroll.focus(kbItem.element[0]);\n                },\n                invoke: function () {\n                    return false;\n                }\n            });\n        }\n    };\n});","/**\n * kb-select directive\n *\n * Usage:\n * <div kb-select ng-model=\"selection\"> ... <div kb-item=\"aItem\">...</div> ... </div>\n */\nangular.module('keyboard').directive('kbSelect', function (KbContainerController, kbScroll) {\n    return {\n        controller: KbContainerController,\n        require: ['kbSelect', 'ngModel'],\n        link: function ($scope, el, attrs, controllers) {\n            var kbContainer = controllers[0];\n\n            kbContainer.initialize({\n                identifier: '[kb-select]',\n                ngModel: controllers[1],\n                attrs: attrs,\n                activate: function (kbItem) {\n                    this.active = kbItem;\n                    kbScroll.focus(kbItem.element[0]);\n                },\n                invoke: function (kbItem) {\n                    this.toggle(kbItem.model);\n                    return true;\n                }\n            });\n        }\n    };\n});","/**\n * Service for setting the focus on elements with the kb-focus directive.\n *\n * Inspired by ng-focus-on\n * @link https://github.com/goodeggs/ng-focus-on\n *\n * Usage:\n * kbFocus('email'); // set focus\n * kbFocus(); // get current focus\n */\nangular.module('keyboard.focus').factory('kbFocus', function ($log) {\n    var _label = ''; // Current focussed label\n\n    /**\n     * Getter and setter for the focus.\n     *\n     * @param {String} label\n     * @returns {String}\n     */\n    var kbFocus = function (label) {\n        if (arguments.length === 0) {\n            return _label;\n        }\n        kbFocus.set(label);\n    };\n    kbFocus.get = function () {\n        return _label;\n    };\n    kbFocus.set = function (label) {\n        if (typeof label === 'string') {\n            _label = label;\n        } else {\n            $log.error('[kbFocus] label must be a string, got', label);\n        }\n    };\n    kbFocus.reset = function () {\n        _label = '';\n    };\n    return kbFocus;\n});\n\n","/**\n * Helper for scrolling an element into the viewable area.\n *\n * Usage:\n * kbScroll.to(el, offset, duration)\n */\nangular.module('keyboard').service('kbScroll', function ($window) {\n\n    // Most browsers scroll via scrollTop on the <body> element.\n    var viewportNode = 'BODY';\n    if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {\n        viewportNode = 'HTML'; // Except Firefox, which uses scrollTop on <html> element.\n    }\n\n    var kbScroll = this;\n\n    /**\n     * Change the scrollposition animated and return a function that cancels the animation.\n     *\n     * @param {Element} container\n     * @param {String} property 'scrollTop' or 'scrollLeft'\n     * @param {Number} value\n     * @param {Number} duration\n     * @returns {Function}\n     */\n    this.change = function (container, property, value, duration) {\n        if (duration && angular.element.prototype.animate) { // jQuery.animate is available?\n            var el = angular.element(container);\n            var props = {};\n            props[property] = value;\n            el.animate(props, duration);\n            return function () {\n                el.stop(true, true);\n            };\n        } else {\n            container[property] = value;\n            return angular.noop;\n        }\n    };\n\n    /**\n     * Get the scrollcontainer of the given element\n     * @param {Element} el\n     * @returns {Element}\n     */\n    this.getScrollParent = function (el) {\n        var parent = el.parentElement;\n        while (parent.nodeName !== viewportNode) {\n            var parentStyle = getComputedStyle(parent);\n            var overflowStyle = parentStyle.overflow + parentStyle.overflowX + parentStyle.overflowY;\n            if (overflowStyle.match(/scroll|hidden/)) {\n                break;\n            }\n            parent = parent.parentElement;\n        }\n        return parent;\n    };\n\n    /**\n     *\n     * @param {Element} el  The DOMElement\n     * @param {Object} offset  Allowed hidden\n     * @param {Number} duration  Duration of the animation in ms\n     * @returns {Function} cancel animation\n     */\n    this.to = function (el, offset, duration) {\n        var cancelAnimation = angular.noop;\n        var parent = kbScroll.getScrollParent(el);\n        var elRect = el.getBoundingClientRect();\n        var pos = {\n            top: Math.ceil(elRect.top),\n            right: Math.ceil(elRect.right),\n            bottom: Math.ceil(elRect.bottom),\n            left: Math.ceil(elRect.left)\n        };\n        // @todo Add outline-width to pos\n        if (parent.nodeName === viewportNode) {\n            var parentPos = {\n                top: 0,\n                right: $window.innerWidth,\n                bottom: $window.innerHeight,\n                left: 0\n            };\n        } else {\n            var parentRect = parent.getBoundingClientRect();\n            var parentPos = {\n                top: Math.ceil(parentRect.top),\n                right: Math.ceil(parentRect.right),\n                bottom: Math.ceil(parentRect.bottom),\n                left: Math.ceil(parentRect.left)\n            };\n        }\n//        console.info(el.nodeName, pos, 'in', parent.nodeName, parentPos, 'offset', offset);\n\n        var relTop = pos.top - parentPos.top;\n        var relRight = parentPos.right - pos.right;\n        var relBottom = parentPos.bottom - pos.bottom;\n        var relLeft = pos.left - parentPos.left;\n\n        if (relTop + offset.top < 0) { // up\n            cancelAnimation = kbScroll.change(parent, 'scrollTop', parent.scrollTop + relTop + offset.top, duration);\n            relBottom += relTop;\n            relTop = 0;\n        } else if (relBottom + offset.bottom < 0) { // down\n            cancelAnimation = kbScroll.change(parent, 'scrollTop', parent.scrollTop - relBottom + offset.bottom, duration);\n            relTop += relBottom;\n            relBottom = 0;\n        }\n        if (relLeft + offset.left < 0) { // left\n            cancelAnimation = kbScroll.change(parent, 'scrollLeft', parent.scrollLeft + relLeft + offset.left, duration);\n            relRight += relLeft;\n            relLeft = 0;\n        } else if (relRight + offset.right < 0) { // right\n            cancelAnimation = kbScroll.change(parent, 'scrollLeft', parent.scrollLeft - relRight + offset.right, duration);\n            relLeft += relRight;\n            relRight = 0;\n        }\n        if (parent.nodeName === viewportNode) {\n            return cancelAnimation;\n        }\n        var cancelParentAnimation = kbScroll.to(parent, {top: relTop, right: relTop, bottom: relBottom, left: relLeft}, duration);\n        return function () {\n            cancelAnimation();\n            cancelParentAnimation();\n        };\n    };\n\n    var cancelFocus = angular.noop;\n    /**\n     * Focus an element\n     * @param {Element} el\n     */\n    this.focus = function (el) {\n        cancelFocus();\n        var parentEl = this.getScrollParent(el);\n        var scrollOffset = {\n            top: parentEl.scrollTop,\n            left: parentEl.scrollLeft\n        };\n        if (!el.hasAttribute('tabindex')) {\n            el.setAttribute('tabindex', 0);\n        };\n        el.focus();\n        if (parentEl.scrollTop !== scrollOffset.top || parentEl.scrollLeft !== scrollOffset.left) { // position changed?\n            parentEl.scrollTop = scrollOffset.top;\n            parentEl.scrollLeft = scrollOffset.left;\n            cancelFocus = this.to(el, {top: 0, right:0, bottom:0, left: 0}, 200);\n        }\n    };\n});\n"],"sourceRoot":"/source/"}